\section{Approach}\label{sec:approach}

%Maybe start with something like, to coep with the presented problem, we propose to automatically generate profilers from an abstract description of its usage and, we propose a DSL to describe the profiler. Our approach is a tooled DSL which enable the description and generation of specific profiler.
In this paper, we propose an approach to easily provide memory monitoring at runtime that can be used for in-production systems. 
Our approach aims at providing a tool that can offer a good tradeoff between the effort needed to write the memory monitoring tool and the performance of this tool.
To reach this goal, we propose a Domain Specific Language (DSL) and its code generator which aims at easily describing and generating efficient online memory analyzers. 


Memory profilers aim at capturing relevant information regarding how an application use the objects in memory.
The data captured by profilers can be as simple as the number of objects of a specific class, but it can also be complex information such as the list of possible memory leak sources.
Most production ready profilers nowadays are able to provide different kinds of information - usually with queries and reports.


Since our goal is to create specific profilers, we use along this paper the term memory analysis to refer to any kind of process to retrieve data about the objects in memory.
For instance, finding the number of objects reachable from a given class object is a type of memory analysis.
A second example is finding out if there is an instance of a class $A$ which is referencing an instance of class $B$.
A last example is computing for each instance of the class \textit{String} its length and the number of references to it.
We can notice that the nature of the output varies among these examples: an integer, a boolean and a compound value.

In general, we see the execution of a memory analysis as a two steps process, i) finding a list of subgraph in the graph of live objects, and ii) computing properties on each subgraph.
In our approach we constrain both, the kind of subgraph users can express and the properties that can be computed on such subgraphs.
The reason to enforce these constrains is to guarantee the efficient execution of the analysis. 

We next present the syntax, semantic and usage examples of our domain-specific language.

\subsection{Language Design}
The full abstract syntax of the language is shown in Figure~\ref{fig:syntax}. 
In this paper, we borrow mathematical symbols such as $\wedge$, $\vee$, $\in$ to simplify the description of the language.
The reader should treat them as shorthand for the actual terminals defined in the language.
Likewise, the definition of non-terminals such as \textit{id}, \textit{IntLit}, \textit{StringLit}, \textit{BoolLit} and \textit{RelOp} is omitted because they correspond to the usual identifier, literals for primitive types and relational operators which exist in most programming languages.  
The four production rules for non-terminal \textit{a} is also worth to describe, note that it corresponds to the definition of a lambda expression which is surrounded by the terminals \textit{`['} and \textit{`]'} which are also special symbols in EBNF notation.

\begin{figure}[!ht]
\begin{align*}
\textit{Analysis} =&\; \{ \textit{Type} \} \; \{ \textit{Set} \} \; \{ \textit{Instance} \} \\
\textit{Type} =&\; \textit{id}:\left(\textit{\textbf{`table-of'}} \; \textit{id} \;|\; \textit{\textbf{`struct'}} \;  \{ \textit{Decl} \} \; \textit{\textbf{`end'}}\right) \\
\textit{Decl} =&\; \textit{id}: \left( \textit{id} \;|\; \textit{\textbf{`int'}} \;|\; \textit{\textbf{`bool'}} \;|\; \textit{\textbf{`string'}} \right) \\
\textit{Set} =&\; \textit{\textbf{`set-type'}} \: \textit{s} : \textit{Property} \: \{ \textit{Property} \} \\
\textit{Property} =&\; \textit{DataID} \leftarrow \textit{e} \\
\textit{DataID} =&\; \textit{\textbf{`roots'}} \;|\; \textit{\textbf{`membership'}} \;|\; \\   &\textit{\textbf{`on-inclusion'}} \;|\; \textit{Decl}  \\
\textit{Instance} =&\; \textit{\textbf{`instances-for'}} \: \textit{id} \: \textit{\textbf{`have-names'}} = \textit{a} \\
e  =&\; r \;|\; b \land b \;|\; b \lor b \;|\; \neg b \\
r =&\; o \;|\; o \; \textit{RelOp} \; o \;|\; o \; \textit{\textbf{`is'}} \; \textit{id} \;|\;\\ 
	& o \in \left(\textit{\textbf{`Unassigned'}} \;|\; \textit{\textbf{`Entity'}} \right) \\
o =&\; \textit{Prefixed} \;|\; o + o \;|\; o - o \;|\; o * o \;|\; o / o\\
\textit{Prefixed} =&\; -a \;|\; \textit{a} \left[ \textit{`.'} \textit{Member} \right] \\
\textit{Member} =&\; \textit{id} \left[ \textit{`('} {e} \textit{`)'} \right] \{ \textit{`.'} \textit{Member} \} \\
a =&\; \textit{id} \;|\; \textit{`('} e \textit{`)'} \;|\; \textit{Literal} \;|\; \\ 
	&\textit{`['} \{\textit{Decl}\} `|' \{\textit{id} \leftarrow e\} \; [ \textit{\textbf{`ret'}} \; e ] \textit{`]'} \\
\textit{Literal} =&\; \textit{IntLit} \;|\; \textit{StrLit} \;|\; \textit{BoolLit} \;|\; \textit{`\#['} \; \textit{Lst-Expr} \; \textit{`]'} \;|\; \\
				&\textit{\textbf{`struct'}} \; \textit{id} \; \textit{Lst-Expr} \; \textit{\textbf{`end'}} \\
\textit{Lst-Expr} =&\; e \; \{ \textit{`,'} \; e \}
\end{align*}
\line(1,0){250}
\caption{DSL syntax in a simplified EBNF notation; the operators for concatenation and termination are not used.
Note that the non-terminals \textit{id}, \textit{IntLit}, \textit{StrLit}, \textit{BoolLit} are undefined.
They correspond to identifiers, integer constants, string constants as in Java and the boolean constants.}
\label{fig:syntax}
\end{figure}

A program in our DSL describes three elements: i) the non-terminal \textit{Type} defines new types of outputs for the analysis, ii) symbol \textit{Set} defines both a type of subgraph by declaring its pattern and how to compute the output for such type of subgraph, and iii) \textit{Instance} defines how many subgraphs of a type should be created and how to identified them.

In addition to the built-in data types, our DSL provides support to define compound types such as structures and lists.
As expected, these types can be arbitrarily composed to provide complex outputs.
As shown in the syntax, the language includes primitive types.
However it also includes the following built-in types: structures \textit{Object}, \textit{Class}, \textit{Classloader}, \textit{Thread} and \textit{ThreadGroup}; and lists of each structure.
These types have the usual relationships: a \textit{Class} is an \textit{Object}, an \textit{Object} is instance of a \textit{Class}, a \textit{Class} was loaded for a \textit{Classloader} and so on.
This means, for instance, that if $o$ is a value of type \textit{Object} then \textit{o.class.name} is the name of the class of this object while \textit{o.class.classloader} is the \textit{Classloader} that loaded the class.

Every list type, either built-in or declared with \textit{table-of}, contains members to declaratively manipulate values of the list.
The table~\ref{tab:members} contains a sample of such members.
The complete set of members only includes those that can be implemented in constant or linear time.  

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline \textbf{Member} & \textbf{Return Type} \\ 
%\hline (\textit{table-of} $T$).append(\textit{table-of} $T$) & \textit{table-of} $T$ \\ 
\hline (\textit{table-of} $T$).foreach($T\to\textit{void}$) & void \\ 
\hline (\textit{table-of} $T$).filter($T\to\textit{bool}$) & \textit{table-of} $T$ \\ 
%\hline (\textit{table-of} $T$).forall($T\to\textit{bool}$) &  \textit{bool} \\ 
\hline (\textit{table-of} $T$).exists($T\to\textit{bool}$) &  \textit{bool} \\ 
%\hline (\textit{table-of} $T$).findfirst($T\to\textit{bool}$) & $T$ \\ 
\hline (\textit{table-of} $T$).map($T \to M$) & $\textit{table-of} \; M$ \\ 
\hline 
\end{tabular} 
\caption{Members defined for each lists type.}\label{tab:members}
\end{table}

The second element we defined in an analysis is the type of subgraph we want to find in the graph of live objects.
This means that we want to identify subgraphs with a specific pattern and compute some values on them.
As we already mentioned, this process contains two steps, subgraph identification and output calculation.
The subgraph identification or matching step depends on two properties - \textit{roots} and \textit{membership}.
To build a subgraph instance by matching, the graph of live object should be traversed.  
The \textit{roots} property establishes the set of objects/nodes that belong to the subgraph before the traversal.
Every time a node is visited during the traversal, and if it does not belong to another subgraph instance, the system evaluates the \textit{membership} property to decide if such a node must be included in the instance.
This step is fully shown in listing~\ref{lst:onNodeFound}.

\begin{lstlisting}[escapeinside={(*}{*)},caption=Routine executed for each reference traversed to calculate if a node belongs to a subgraph, label=lst:onNodeFound,float=!h, language=AlgLang]
routine include_in_subgraph
input:
	(*$C$*) // subgraph instances
	THIS // the current object being explored
	Context
action:
	if (*$\exists {i \in 1..\left\vert{C}\right\vert}, \quad {\text{THIS} \in C_i}$*)
		return stop_traversing_this
	foreach (*$C_i \in C$*)
		if (*$C_i\textit{.membership}$(\text{THIS}, \textit{Context})*)
			(*$C_i \leftarrow C_i \cup \left\{\text{THIS}\right\}$*)
			return traverse_this
	return stop_traversing_this
\end{lstlisting}

The step of values computation depends on user-defined properties and the \textit{on-inclusion} built-in property.
Again, user-defined properties are evaluated once before the graph traversal while \textit{on-inclusion} is evaluated for each visited node.
Listing~\ref{lst:onNodeFoundData} shows how this step uses the listing~\ref{lst:onNodeFound} to guarantee that the contribution of the new node to the output is added just once.

\begin{lstlisting}[escapeinside={(*}{*)},caption=Routine executed for each reference traversed to calculate the output value of a subgraph, label=lst:onNodeFoundData,float=!h, language=AlgLang]
routine calculate_value_for_subgraph
input:
	(*$C$*) // subgraph instances
	(*$\textit{THIS}$*) // the current object being explored
	Context
action:
	if include_in_subgraph((*$C$*), THIS, Context) is traverse_this
		Let (*$C_i \in C, THIS \in C_i$*) 
			(*$C_i\textit{.output} \leftarrow C_i\textit{.on-inclusion}(\textit{THIS}, \textit{Context}, C_i\textit{.output}) $*)
\end{lstlisting}

The overall strategy to match the subgraph resembles the strategy used by declarative approaches to graph query such as SPARQL~\cite{Buil-Aranda:2013:FQS:2435469.2435851} and Cypher~\cite{Holzschuher:2013:PGQ:2457317.2457351}.
In this kind of query, it is common to provide initial starting points to accelerate the execution of the query. 
Such starting points are member of the matched subgraph. 

The third element of a program is the definition of how many subgraph instances the system must identify.
In our DSL, we make use of the type pattern along with a declarative approach to describe the instance we are interested in and to avoid its explicit enumeration.
The procedure to create the instances is shown in listing~\ref{onInitialization}.
It basically iterates over all the \textit{Instance} constructors and set up the initial values of each subgraph. 

\begin{lstlisting}[escapeinside={(*}{*)},caption=Using classes of tuples to define the set $C$., label=onInitialization,float=!h, language=AlgLang]
input:
	(*$\textit{ST}$*) // types of subgraphs
	V // living objects 
	Context
action:
	(*$C \leftarrow \emptyset $*) // subgraph instances
	foreach (*${T}_i \in {ST}$*)
		(*$\textit{Subgraphs} \leftarrow {ST}_i\textit{.names}\left({V}, \textit{Context}\right)$*)
		foreach (*$S_j \in \textit{Subgraphs}$*)
				initialize (*$\textit{roots}$*) using (*$\textit{Context}$*)
				initialize (*$\textit{user-defined properties}$*)
		(*$C \leftarrow C \cup \textit{Subgraphs}$*)
	return (*$C$*)
	
\end{lstlisting}

The complete execution of a program in our language is as follow. Subgraph instances are initialized using listing~\ref{onInitialization}.
Afterward, all the references in the graph of objects are traversed running listing~\ref{lst:onNodeFoundData}.
The output data for all subgraph instances has been collected after all the references are traversed once.

Finally, in listings~\ref{lst:onNodeFound},~\ref{lst:onNodeFoundData} and~\ref{onInitialization} we use built-in properties that are defined by the user.
These properties must have access to some data describing the content of the memory in order to successfully identify subgraphs and calculate output values.
Such data is wrapped in what we call execution context.
In our DSL there are two different execution contexts: \textit{global context} and \textit{local context}.
The former includes built-in values such as: i) lists of \textit{objects}, \textit{threads}, \textit{classes}, etc. , and ii) a value called \textit{Entity} representing a subgraph instance.
The latter only contains the object \textit{THIS} which is being visited, a label of the reference representing its type, \textit{REFERRER} which is the object referencing the visited and again the \textit{Entity} value.
The \textit{global context} is available in listing~\ref{onInitialization} while the \textit{local context} is available in both listings~\ref{lst:onNodeFound} and~\ref{lst:onNodeFoundData}.

%The idea of the approach is highly driven by the motivating scenario discussed in section~\ref{sec:motivation}.
%In short, we propose to split the set of living objects in different disjoint subsets and we associate arbitrary extracted information to each subset.
%In order to keep the overhead as low as possible, we propose collecting such information in a single
%traversal of the graph.
%In the rest of this section, we presents the details of the approach.

%Let $G=(V,E)$ be a graph representing the living objects in the heap.
%The approach aims at building a set $C$ of tuples with the form $T_i=\langle{Id}_i,O_i, s_i, m_i, a_i, D_i\rangle$
%where members of a tuple $T_i$ are described as follows:

%The first member of the tuple is an unique identifier of such a tuple.
%Although it may look redundant it actually helps during the practical implementation of the approach.

%The second member of the tuple, $O_i$, is a set of living objects with the properties described below.
%\begin{align*}
%    \cup_{i \in 1..\left\vert{C}\right\vert}{O_i} \subseteq V \\
%    \forall {i,j \in 1..\left\vert{C}\right\vert}, \quad {O_i \cap O_j = \emptyset}
%\end{align*}
%
%The set $D_i$ describes the information we want to collect from the heap.
%The definition below depends on three sets: i) the set $\textit{Labels}$ which contains a unique
%name for each member in $D_i$, ii) the set $\textit{Types}$ which describe the type of each label, and
%the set $\textit{Values}$ which is the universe of valid values for a given type. 
%\[ D_i := \left\{ (l, t ,v) \vert l \in{\textit{Labels}}, t\in{\textit{Types}},v\in{\textit{Values}} \right\} \]
%
%The functions $s_i$, $m_i$ and $a_i$  are called initialization, membership and action functions respectively. These functions are used to define the sets $O_i$ and $D_i$ during the traversal of
%the graph $G$.
%\begin{align}
%	s_i \colon  \mathcal{P}(V) &\to \mathcal{P}(V) \label{eq:a1} \\
%	m_i \colon V &\to \left\{{true, false}\right\} \label{eq:a2} \\
%	a_i \colon V\times{D_i} &\to D_i \label{eq:a3}
%\end{align}
%
%In our modeling, we also cluster tuples in $C$ into different classes.
%A class of tuples is a tuple with the form $TC=\langle{f_i,s_i,m_i,a_i}\rangle$ where
%$s_i$, $m_i$ and $a_i$ follow the definitions~\ref{eq:a1},~\ref{eq:a2},~\ref{eq:a3} while
%the form of $f_i$, which we call instantiation function, is defined below:
%\begin{align*}
%f_i \colon \mathcal{P}(V) \to \mathcal{P}(C)
%\end{align*}

%The need for the concept of classes of tuples is better understood using the motivating example.
%In the case of accounting memory consumption for OSGi bundle, we have two classes of tuples.
%The first class is composed by tuples that represent a single bundle, but all of them use the same
%Java abstractions.
%The second class of tuples contains the set of objects that are consumed by the Java runtime itself.
%It is clear that we cannot list all the tuples because we cannot know in advance how many bundles will be running. However, we can list all the classes of tuples.

%To build the set of tuples $C$, our approach performs the following steps.
%It begins by executing the code shown in listing~\ref{onInitialization} to create and initial version of $C$.
%In the code, we first create instances of each class of tuples using the functions $f_i$.
%Then, we initialized each tuple with its initial version of $O_i$ and $D_i$.

%In this paper, we define a DSL that implements the presented concepts.
%This language provides constructors to specify the kind of information you want to collect, in other words, these constructors allow you to define $Types$ and $D_i$.
%The language also provides constructors to define the classes of tuples, which implies the definition of the functions $f_i$, $s_i$, $m_i$ and $a_i$.

\subsection{Language Usage}

There are several possibilities for using our DSL in the course of regular software maintenance.
These include checking: local data structure invariants, reachability properties, memory consumption properties and combinations of those.
Below, we show some examples to highlight possible usage of our language. 
 
Listing~\ref{assertion} shows an example to assert the existence of a value satisfying some properties, independently of which data structure contains it. 
The result is obtained through the use of a filter on the list of objects.
The result of listing~\ref{assertion} will be $true$ if the heap contains an object with an attribute named $data$ with a value comprised between $3.141$ and $3.142$.

\begin{lstlisting}[escapeinside={(*}{*)},
caption={
Detecting if an object satisfying certain property exists.
Observe that we are not using the keyword \textit{ret}.
We avoid it for the sake of clarity.
The reader should treat along this paper any final expression $e$ within a lambda as \textit{ret} $e$. },
label=assertion,float=!h, language=DSL]
set_type all: 
	roots (*$\leftarrow$*) objects(*{.filter}*)([it | it.data > 3.141 (*$\wedge$*) it.data < 3.142])
	membership (*$\leftarrow$*) false
	on_inclusion (*$\leftarrow$*) [ fault (*$\leftarrow$*) true ]
	fault : bool (*$\leftarrow$*) false
instances_for all have_names = "all-jvm"
\end{lstlisting}

The goal of listing~\ref{pseudojbb} is to detect a known bug identified in~\cite{Aftandilian:2009:GAU:1543135.1542503}.
This listing aims at finding if an object of type $Order$ is present 
with the value of its field $field$ being equal to $specialValue$.
This technique is used to detect if one object has been garbage collected or if someone still hold a reference on it preventing its garbage collection.
\begin{lstlisting}[escapeinside={(*}{*)},caption=Detecting a knwon bug in pseudojbb., label=pseudojbb,float=!h, language=DSL]
set_type all: 
	roots (*$\leftarrow$*) objects(*{.filter}*)([it | it is Order])
	membership (*$\leftarrow$*) false
	on_inclusion (*$\leftarrow$*) [ fault (*$\leftarrow$*) fault (*$\lor$*) THIS.field = specialValue ]
	fault : bool (*$\leftarrow$*) false
instances_for all have_names = "all-jvm"
\end{lstlisting}

The next example computes a combination of reachability and memory consumption properties.
It calculates the number of objects, and their total memory consumption, that are reachable from the threads.
We can notice in listing~\ref{kevoreeaccounting} how the membership property discard those objects that are not referenced by an already included object.  

\begin{lstlisting}[escapeinside={(*}{*)},caption=Calculating objects reachables from threads, label=kevoreeaccounting,float=!h, language=DSL]
	roots (*$\leftarrow$*) threads
	membership (*$\leftarrow$*) THIS (*$\in$*) Unassigned (*$\land$*) REFERRER (*$\in$*) ENTITY
	on_inclusion (*$\leftarrow$*) [      
		nbObjects (*$\leftarrow$*) nbObjects + 1  
		nbSize (*$\leftarrow$*) nbSize + THIS.size
	]
	nbObjects : int (*$\leftarrow$*) 0 // user-defined properties attached to each instance
	nbSize : int (*$\leftarrow$*) 0 
instances_for all have_names = "all-jvm"
\end{lstlisting}

We can also express complex structures in memory.
For instance, to find the consumption of K3-Al object namely \textit{K3Object} as described in section~\ref{sec:motivation}, we must find all instances of \textit{HashMap.Entry} that have \textit{K3Object} as the \textit{key}. These entries should be added to the consumption of the object \textit{K3Object} as well as all the objects reachable from the \textit{HashMap.Entry.value}.
To come out with this solution a good understanding of how K3-Al implements aspects is required.
The rationale here is that K3-Al stores the state of aspects in a separate HashMap, using as key the object to be aspectized.
\begin{lstlisting}[escapeinside={(*}{*)},caption=Computing the consumption of each K3-Al Object along with its aspects., label=k3,float=!h, language=DSL]
set_type all: 
	roots (*$\leftarrow$*) objects(*{.filter}*)([it | it is K3Object (*$\land$*) it(*{.id}*) = ENTITY.name])
 	membership (*$\leftarrow$*) (REFERRER (*$\in$*) ENTITY (*$\land$*) THIS (*$\in$*) Unassigned ) (*$\lor$*)
		( THIS is HashMap.Entry (*$\land$*) 
		  THIS.key (*$\in$*) ENTITY (*$\land$*) THIS.key is K3Object)
	on_inclusion (*$\leftarrow$*) [ nbSize (*$\leftarrow$*) nbSize + THIS.size ]
 	nbSize : int (*$\leftarrow$*) 0 
instances_for all have_names = objects(*{.filter}*)([it|it is K3Object]).map([it|it(*{.id}*)]) 
\end{lstlisting}

Finally, we can use the language to compute the consumption of the \textit{top components}. This kind of analysis account for the consumption of the root objects $O$ to the \textit{classloader} that loaded the class of $ O $. It is often used as a rough approximation of OSGi bundles' consumption. 

\begin{lstlisting}[escapeinside={(*}{*)},caption=Calculating the consumption of top components, label=topcomponents,float=!h, language=DSL]
set_type Component: 
	roots (*$\leftarrow$*) classloaders(*{.filter}*)([ it | (*{it.id}*) = ENTITY.name ])  
	membership (*$\leftarrow$*) THIS (*$\in$*) Unassigned (*$\land$*) (
					(ref_kind = root (*$\land$*) THIS.class.classloader (*$\in$*) ENTITY) (*$\lor$*)
					(ref_kind (*$\neq$*) root (*$\land$*) REFERRER (*$\in$*) ENTITY)
				 )
	on_inclusion (*$\leftarrow$*) [ nbSize (*$\leftarrow$*) nbSize + THIS.size ]
	nbSize : int (*$\leftarrow$*) 0
instances_for Component have_names = classloaders.map([ it | (*{it.id}*) ])  
\end{lstlisting}