\selectlanguage{english}
\chapter{Building Efficient Domain-Specific Memory Profilers}
\markboth{Building Efficient Domain-Specific Memory Profilers}{Chapter6}

%#Context  
Domain-specific abstractions are increasingly used in industry to ease the development of applications. These abstractions take various forms, (e.g., domain-specific languages (DSL), macros, component models). Workbenches exist to define tooling over such abstractions. For example, DSL workbenches support the development of editors and code generators. 
% #Problem 
However, profiling applications which use these abstractions requires significant development efforts to keep the traceability links between these abstractions and the runtime data-structures. This effort must be balanced with the limited audience of these abstractions. 
Sate of the art profilers are able to represent such abstractions through generic query evaluation, but they suffer from bad performance issue. 

%#Contribution
In this paper, we propose an approach to ease the development of efficient memory analysis tools to be used during the production stage.
Our approach provides a DSL to express the mapping between abstractions and runtime data structure.
At runtime, the generated  memory analysis tools leverage the object graph traversal mechanism to efficiently collect the specific memory data required.
%#Evaluation
To evaluate our approach, we compare memory analysis tools produced with our DSL against: i) hand written optimized solutions, and ii) solutions based on existing tools which offer lower performance.
The results show that our approach offers performance gain compared to previous solutions, and simplify the definition of memory analysis tools.

\input{chapter6/languages_for_listings}

\input{chapter6/introduction}

%\input{background}

\input{chapter6/motivation}

\input{chapter6/approach}

\input{chapter6/implementation}

\input{chapter6/expressiveness}

\input{chapter6/evaluation}

%\input{chapter6/RelatedWork}

\section{Conclusions and Future Works}\label{sec:conclusions}

In this paper, we propose a Domain Specific Language for expressing the mapping between abstractions and runtime data structure to collect information about the memory heap in production. This language provides an abstraction that is useful to reason about the heap and is, at the same time, easy to translate into a set of low-level routines to efficiently collect the desired information.
In our opinion, this approach is a step forward in the creation of resource-aware software systems for two reasons. 
First, it reduces the complexity of defining customized queries; hence, developers and operators are able to use this feature to solve new problems without the need of high expertise on runtime internals.
Second, such customized queries can be used in a production environment since they have a limited impact on the system's performance.

In the future, we plan to address the limitations of the execution model we propose.
In particular, we are aware that it is not as powerful as other query languages since it is based on a single traversal of the graph.
The advantages of the chosen approach are that it guarantees a low impact on the performance and it is easy to weave with existent technique to explore the heap.
An alternative we consider is to leverage the results from graph databases.
It would provide two benefits: i) algebraic transformation of the queries with all the potential optimizations and, ii) an already known language for developers.


