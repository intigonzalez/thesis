\section{Discussion On Language Expressiveness}\label{sec:expressiveness}

In our DSL, the mechanism used to collect data is explicit to the user.
Hence, it is possible to estimate the overhead of a specific profiler.
In short, our DSL follows the imperative paradigm to obtain derived values.
On the contrary, most query languages provide a declarative style because it \textit{simplifies} writing new queries.

%Designing a domain specific language for memory analysis is a deliberate attempt to make explicit to the user what is the complexity of the analysis he tries to perform.
We acknowledge that our approach limits the kind of memory analysis that users can express.
First, it is not possible to recover all the information contained in the graph of live objects in linear time on the number of objects.
Second, an imperative style forces the users to understand the underlying execution model which is not required with declarative query languages.
Nonetheless, we claim that getting rid of some expressiveness is a trade-off worth considering in order to guarantee efficient memory analysis.
The empirical and theoretical evidence suggest that, in our DSL, \textit{reducing the capabilities to collect data} has a bigger impact on performance gain than \textit{generating efficient native code} to collect data.

At this point, it is worth noting why declarative approaches fail to deliver the adequate performance in production.
Listings~\ref{k3OQL} and~\ref{k3Cypher} show possible solutions, in OQL and Cypher/Neo4j, to the K3-Al example presented in section~\ref{sec:motivation}.
There are two aspects affecting the performance of this kind of queries.
We next discuss them.

\begin{lstlisting}[escapeinside={(*}{*)},caption={Using OQL to compute the consumption of each K3-Al object. Actually, this query cannot be executed in Eclipse Mat nor in VisualVM since they do not provide a full OQL implementation. }, label=k3OQL,float=!h, language=OQL]
SELECT id, sum(size) as s
FROM (
	SELECT
		e.key.@objectId AS id, 
		e.@usedHeapSize + e.value.@retainedHeapSize AS size
	FROM java.util.HashMap$Entry e
	WHERE (classof(e.key).@name = "K3Object")
	UNION ALL
	SELECT 
		k3.@objectId AS id, k3.@retainedHeapSize AS size 
	FROM K3Object k3
)
GROUP BY id
\end{lstlisting}

In the first place, many queries are intrinsically complex to answer.
For instance, it is known that answering SPARQL queries - which was used as inspiration for Cypher/Neo4j, is PSPACE-complete~\cite{Schmidt:2010:FSQ:1804669.1804675, Perez:2009:SCS:1567274.1567278}.
The performance of declarative queries for in production memory analysis is also affected by the nature of data we are exploring. 
Indeed, even if they can be executed efficiently, the optimization steps required are in most cases impossible to execute for the type of data we are considering - a graph of objects that constantly changes.
Often, these query optimizations require access to indexes, additional storage and multiples passes on the data~\cite{Elhemali:2007:ESS:1247480.1247598, Dageville:2002:SMM:1287369.1287454} that are not accessible on the graph of objects.
\begin{lstlisting}[escapeinside={(*}{*)},
caption={Using Cypher to compute the consumption of each K3-A1 object.}, label=k3Cypher,float=!h, language=CYPHER]
MATCH 
	(key:K3Object)<-[:key]-(entry:HashMap$Entry)-[:value]->value
WITH entry, key, value
MATCH 
	key-[:1..1]->fieldK
WITH entry, key, value, fieldK
MATCH 
	value-[:1..1]->fieldV
RETURN key, entry.size + key.size + fieldK.size + sum(value.size) + sum(fieldV.size);
\end{lstlisting}

On the contrary, our language makes explicit both the time and space complexities of the analysis.
We also believe that the mental model required to code profilers with our DSL is simple enough since
we mimic the popular ``think as a vertex'' paradigm of Pregel which has proven to be successful~\cite{Malewicz:2010:PSL:1807167.1807184}.
In this paradigm, an algorithm on graph is described from the point of view of each vertex.
In our case the \textit{membership function} and the \textit{update section} are also executed using a limited context which only includes a few built-in rvalues.

%Finally, we have shown along this paper how to collect meaningful data with ou DSL.
%Nonetheless, it is worth mentioning that the class of common  

%\begin{lstlisting}[escapeinside={(*}{*)},caption=Detecting a knwon bug in pseudojbb., label=pseudojbbOQL,float=!h, language=OQL]
%SELECT o
%FROM Order o
%WHERE o.field = specialValue
%\end{lstlisting}