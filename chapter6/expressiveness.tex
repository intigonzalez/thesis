\section{Discussion On Language Expressiveness}\label{sec:expressiveness}

A main feature of our approach is that it makes explicit how the data is collected.
In short, our language follows the imperative paradigm when it comes to data collection.
However, many well-known and established languages to recover data provide a declarative style because it simplifies the coding of queries.

Designing a domain specific language for memory analysis is a deliberate attempt to make explicit to the user what is the complexity of the analysis he tries to perform.
We acknowledge that our approach limits,  for two reasons, the kind of memory analysis that users can express.
First, it is not possible to recover all the information contained in the graph of live objects in linear time on the set of objects.
Second, an imperative style forces the users to understand the underlying execution model which is not required with declarative query languages.
Nonetheless, we claim that getting rid of some expressiveness is a trade-off worth to consider in order to guarantee efficient memory analysis.
The rational behind this assumption is that of the two strategies we followed to achieve efficient memory analysis, namely: i) generating efficient native code to collect the data, and ii) reducing the data recollection capabilities by carefully designing the language; the second one has a bigger impact on the performance gain.

At this point, it is worthy noting why declarative approaches fail to deliver the adequate performance in production.
Listings~\ref{k3OQL} and~\ref{k3Cypher} show possible solutions, in OQL and Cypher/Neo4j, to the K3-Al example presented in section~\ref{sec:motivation}.
There are two aspects affecting the performance of this kind of queries.
We next discuss them.

\begin{lstlisting}[escapeinside={(*}{*)},caption={Using OQL to compute the consumption of each K3-Al Object along with its aspects. Actually, this query cannot be executed in Eclipse Mat nor in VisualVM since they do not provide a complete OQL implementation. }, label=k3OQL,float=!h, language=OQL]
SELECT id, sum(size) as s
FROM (
	SELECT
		e.key.@objectId AS id, 
		e.@usedHeapSize + e.value.@retainedHeapSize AS size
	FROM java.util.HashMap$Entry e
	WHERE (classof(e.key).@name = "K3Object")
	UNION ALL
	SELECT 
		k3.@objectId AS id, k3.@retainedHeapSize AS size 
	FROM K3Object k3
)
GROUP BY id
\end{lstlisting}

First, many queries are intrinsically complex to answer.
For instance, it is known that answering SPARQL queries - which was used as inspiration for Cypher/Neo4j, is PSPACE-complete~\cite{Schmidt:2010:FSQ:1804669.1804675, Perez:2009:SCS:1567274.1567278}. 

The second aspect affecting the performance of declarative queries for in production memory analysis lies in the nature of data we are exploring. 
Indeed, even if declarative queries can be executed efficiently, the optimization steps required are in most cases impossible to execute for the type of data we are considering - a graph of objects that constantly changes.
Often, these query optimizations require access to indexes, additional storage and multiples passes on the data~\cite{Elhemali:2007:ESS:1247480.1247598, Dageville:2002:SMM:1287369.1287454} that are not accessible on the graph of objects.

%\todo{cite: Foundations of SPARQL query optimization}

\begin{lstlisting}[escapeinside={(*}{*)},caption=Using Cypher/Neo4j to compute the consumption of each Kermeta 3's Object along with its aspects., label=k3Cypher,float=!h, language=CYPHER]
MATCH 
	(key:K3Object)<-[:key]-(entry:HashMap$Entry)-[:value]->value
WITH entry, key, value
MATCH 
	key-[:1..1]->fieldK
WITH entry, key, value, fieldK
MATCH 
	value-[:1..1]->fieldV
RETURN key, entry.size + key.size + fieldK.size + sum(value.size) + sum(fieldV.size);
\end{lstlisting}

On the contrary, as we already mention, our language makes explicit both the time and space complexities of the analysis.
We also believe that the mental model required to code memory analysis with our DSL is simple enough since
we have tried to mimic the ``think as a vertex'' paradigm of Pregel which has proven to be successful~\cite{Malewicz:2010:PSL:1807167.1807184}.

%\begin{lstlisting}[escapeinside={(*}{*)},caption=Detecting a knwon bug in pseudojbb., label=pseudojbbOQL,float=!h, language=OQL]
%SELECT o
%FROM Order o
%WHERE o.field = specialValue
%\end{lstlisting}